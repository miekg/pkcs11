/* Filename is not ending in .c because it will then be picked up by cgo twice */
#define CK_PTR *
#define CK_DEFINE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION(returnType, name) returnType name
#define CK_DECLARE_FUNCTION_POINTER(returnType, name) returnType (* name)
#define CK_CALLBACK_FUNCTION(returnType, name) returnType (* name)
#ifndef NULL_PTR
#define NULL_PTR 0
#endif
#include "pkcs11.h"
#include <stdlib.h>
#include <stdio.h>
#include <ltdl.h>

struct ctx {
	lt_dlhandle handle;
	CK_FUNCTION_LIST_PTR sym;
};

struct ctx * New(const char *module) {
	if (lt_dlinit() != 0) {
		return NULL;
	}
	struct ctx *c;
	CK_C_GetFunctionList list;
	CK_RV rv;

	c = calloc(1, sizeof(struct ctx));
	c->handle = lt_dlopen(module);
	if (c->handle == NULL) {
		free(c);
		return NULL;
	}
	list = (CK_C_GetFunctionList) lt_dlsym(c->handle, "C_GetFunctionList");
	if (list == NULL) {
		free(c);
		return NULL;
	}
	list(&c->sym);
	// Initialize
	CK_C_INITIALIZE_ARGS InitArgs = {NULL, NULL, NULL, NULL, CKF_OS_LOCKING_OK, NULL};
	rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_Initialize( (CK_VOID_PTR) &InitArgs);
	if (rv != CKR_OK) {
		free(c);
		return NULL;
	}
	return c;
}

// 
void Destroy(struct ctx *c) {
        ((CK_FUNCTION_LIST_PTR)c->sym)->C_Finalize(NULL_PTR);
	if (c->handle == NULL) {
		return;
	}
	if (lt_dlclose(c->handle) < 0) {
		return;
	}
	lt_dlexit();
	free(c);
}

// Return an error code and in the param list: array of slots and the length of
// the array
// Use more normal types here too? See InitToken
CK_RV Slots(struct ctx *c, CK_SLOT_INFO_PTR *slots, CK_TOKEN_INFO_PTR *tokens, CK_ULONG_PTR nslots) {
        CK_RV rv;                                                                                     
        CK_SLOT_ID i, *ids;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(CK_FALSE, NULL_PTR, nslots);
        if (rv != CKR_OK) {
                return rv;
        }
        ids = malloc(sizeof(CK_SLOT_ID) * *nslots);
        if (!ids) {
                return CKR_GENERAL_ERROR; 
        }
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotList(CK_FALSE, ids, nslots);
        if (rv != CKR_OK) {
                free(ids);
                return rv;
        }

        *slots = calloc(1, sizeof(CK_SLOT_INFO) * *nslots);
        *tokens = calloc(1, sizeof(CK_TOKEN_INFO) * *nslots);
        if (!*slots || !*tokens) {
                return CKR_GENERAL_ERROR;
        }
        for (i = 0; i < *nslots; i++) {
                rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetSlotInfo(ids[i], slots[i]);
                // TODO: return code
                if ( (slots[i]->flags & CKF_TOKEN_PRESENT) == CKF_TOKEN_PRESENT) {
                        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo(ids[i], tokens[i]);
                        // TODO(mg): rv return code
                }
        }
        return CKR_OK;
}

CK_RV InitToken(struct ctx *c, CK_TOKEN_INFO_PTR *t, uint id, char * pin, uint pinlen, char * label) {
        CK_RV rv;
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_InitToken((CK_SLOT_ID)id, (CK_UTF8CHAR_PTR)pin, (CK_ULONG)pinlen, (CK_UTF8CHAR_PTR)label);
        if (rv != CKR_OK) {
                return rv;
        }
        *t = calloc(1, sizeof(CK_TOKEN_INFO));
        // re-Read token
        rv = ((CK_FUNCTION_LIST_PTR)c->sym)->C_GetTokenInfo((CK_SLOT_ID)id, *t);
        if (rv != 0) {
                // ...
        }
        // And some more
        return CKR_OK;
}
